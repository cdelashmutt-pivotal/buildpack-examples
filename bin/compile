#!/usr/bin/env python

# The compile script builds the droplet that will be run by the DEA and will 
# therefore contain all the components necessary to run the application.
#
# The script is run with two arguments, the build directory for the 
# application and the cache directory, which is a location the buildpack can 
# use to store assets during the build process.
#
# During execution of this script all output sent to STDOUT will be relayed 
# via CF back to the end user. 
#
# The generally accepted pattern for a more complex compile script is to break 
# out functionality in to a 'language_pack'. A good example of this can be seen 
# at 
# https://github.com/cloudfoundry/heroku-buildpack-ruby/blob/master/lib/language_pack/ruby.rb

# This particular script will simply copy a hello-start.sh script file that 
# will be executed by Cloud Foundry at this application's startup.

import sys
import os
import shutil

#Directory of the buildpack
BP_DIR = os.path.dirname(os.path.dirname(sys.argv[0]))

#The directory the files for the droplet are put
BUILD_DIR=sys.argv[1]
#Our message file for the "app"
MESSAGE_FILE=os.path.join(BUILD_DIR, 'message.msg')
#Name for startup script
START_SCRIPT_NAME='hello-start.sh'
MESSAGE_SERVER_SCRIPT='message-server.sh'

message = ''
with open(MESSAGE_FILE, 'rt') as messageFile:
  message = messageFile.read()

print 'Got message: ', message

print 'Putting start script into droplet'
shutil.copy(
  os.path.join(BP_DIR, START_SCRIPT_NAME),
  os.path.join(BUILD_DIR, START_SCRIPT_NAME)
)

shutil.copy(
  os.path.join(BP_DIR, MESSAGE_SERVER_SCRIPT),
  os.path.join(BUILD_DIR, MESSAGE_SERVER_SCRIPT)
)
